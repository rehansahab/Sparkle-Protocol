{
  "_comment": "Sparkle Protocol BOLT11 Test Vectors v0.3.8",
  "_description": "Valid and invalid invoice test cases for signature/payee/amount validation",

  "valid_invoices": [
    {
      "id": "valid_testnet_1",
      "description": "Valid testnet invoice with correct signature and payee",
      "invoice": "lntb10u1pjtest1pp5uvgrlkwhsq7zgnh0nxfxt06egz8awyufxyhn5e2fj4jv3hgj9t2sdqqcqzpgxqyz5vqsp5test123456789abcdefghijklmnopqrstuvwxyz0123456789abcqs9qyyssqtest",
      "invoice_comment": "This is a placeholder - replace with real testnet invoice for integration testing",
      "expected": {
        "network": "testnet",
        "signature_valid": true,
        "payee_matches_counterparty": true,
        "payment_hash_matches_script": true,
        "amount_matches_offer": true,
        "result": "PASS"
      }
    }
  ],

  "invalid_invoices": [
    {
      "id": "invalid_payee",
      "description": "Valid signature but payee does not match counterparty",
      "scenario": "Invoice signed by node A, but counterparty pubkey is node B",
      "expected": {
        "signature_valid": true,
        "payee_matches_counterparty": false,
        "result": "FAIL",
        "error": "Invoice payee does not match counterparty"
      }
    },
    {
      "id": "invalid_signature",
      "description": "Tampered signature - cannot recover valid pubkey",
      "scenario": "Last byte of signature modified",
      "expected": {
        "signature_valid": false,
        "result": "FAIL",
        "error": "SECURITY: Invoice signature verification failed"
      }
    },
    {
      "id": "wrong_payment_hash",
      "description": "Valid invoice but payment_hash does not match script hashlock",
      "scenario": "Invoice generated for different swap",
      "expected": {
        "signature_valid": true,
        "payment_hash_matches_script": false,
        "result": "FAIL",
        "error": "Payment hash mismatch"
      }
    },
    {
      "id": "wrong_amount",
      "description": "Valid invoice but amount does not match offer price",
      "scenario": "Invoice for 1000 sats, offer price is 10000 sats",
      "expected": {
        "signature_valid": true,
        "amount_matches_offer": false,
        "result": "FAIL",
        "error": "Invoice amount does not match offer"
      }
    },
    {
      "id": "expired_invoice",
      "description": "Valid invoice but already expired",
      "scenario": "Invoice timestamp + expiry < current time",
      "expected": {
        "signature_valid": true,
        "is_expired": true,
        "result": "FAIL",
        "error": "Invoice expired"
      }
    },
    {
      "id": "wrong_network",
      "description": "Mainnet invoice used on testnet (or vice versa)",
      "scenario": "lnbc prefix on testnet network",
      "expected": {
        "network_mismatch": true,
        "result": "FAIL",
        "error": "Invoice network mismatch"
      }
    }
  ],

  "validation_checks": {
    "signature": {
      "description": "Recover pubkey from signature, verify against message hash",
      "message_hash": "SHA256(hrp || data_5bit_words)",
      "must_block_on_invalid": true
    },
    "payee_binding": {
      "description": "Recovered pubkey must match counterparty's Lightning pubkey",
      "must_block_on_mismatch": true
    },
    "payment_hash": {
      "description": "Invoice payment_hash must match hashlock script",
      "must_block_on_mismatch": true
    },
    "amount": {
      "description": "Invoice amount must match swap offer price",
      "tolerance_percent": 0,
      "must_block_on_mismatch": true
    },
    "expiry": {
      "description": "Invoice must not be expired",
      "safe_cltv_formula": "CurrentHeight + (InvoiceExpirySecs / 600) + 12",
      "must_block_if_expired": true
    },
    "network": {
      "description": "Invoice prefix must match expected network",
      "mainnet_prefix": "lnbc",
      "testnet_prefix": "lntb",
      "must_block_on_mismatch": true
    }
  }
}
