/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/@noble/secp256k1@2.1.0/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
const t=2n**256n,n=t-0x1000003d1n,e=t-0x14551231950b75fc4402da1732fc9bebfn,r=0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,s=0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n,i={p:n,n:e,a:0n,b:7n,Gx:r,Gy:s},o=32,a=t=>m(m(t*t)*t+i.b),c=(t="")=>{throw new Error(t)},l=t=>"bigint"==typeof t,u=t=>"string"==typeof t,h=t=>l(t)&&0n<t&&t<n,d=t=>l(t)&&0n<t&&t<e,y=(t,n)=>!(t=>t instanceof Uint8Array||null!=t&&"object"==typeof t&&"Uint8Array"===t.constructor.name)(t)||"number"==typeof n&&n>0&&t.length!==n?c("Uint8Array expected"):t,f=t=>new Uint8Array(t),p=(t,n)=>y(u(t)?A(t):f(y(t)),n),m=(t,e=n)=>{let r=t%e;return r>=0n?r:e+r},x=t=>t instanceof b?t:c("Point expected");class b{constructor(t,n,e){this.px=t,this.py=n,this.pz=e}static fromAffine(t){return 0n===t.x&&0n===t.y?b.ZERO:new b(t.x,t.y,1n)}static fromHex(t){let n;const e=(t=p(t))[0],r=t.subarray(1),s=P(r,0,o),i=t.length;if(33===i&&[2,3].includes(e)){h(s)||c("Point hex invalid: x not FE");let t=V(a(s));!(1&~e)!==(1n===(1n&t))&&(t=m(-t)),n=new b(s,t,1n)}return 65===i&&4===e&&(n=new b(s,P(r,o,64),1n)),n?n.ok():c("Point is not on curve")}static fromPrivateKey(t){return g.mul(k(t))}get x(){return this.aff().x}get y(){return this.aff().y}equals(t){const{px:n,py:e,pz:r}=this,{px:s,py:i,pz:o}=x(t),a=m(n*o),c=m(s*r),l=m(e*o),u=m(i*r);return a===c&&l===u}negate(){return new b(this.px,m(-this.py),this.pz)}double(){return this.add(this)}add(t){const{px:n,py:e,pz:r}=this,{px:s,py:o,pz:a}=x(t),{a:c,b:l}=i;let u=0n,h=0n,d=0n;const y=m(3n*l);let f=m(n*s),p=m(e*o),g=m(r*a),v=m(n+e),w=m(s+o);v=m(v*w),w=m(f+p),v=m(v-w),w=m(n+r);let S=m(s+a);return w=m(w*S),S=m(f+g),w=m(w-S),S=m(e+r),u=m(o+a),S=m(S*u),u=m(p+g),S=m(S-u),d=m(c*w),u=m(y*g),d=m(u+d),u=m(p-d),d=m(p+d),h=m(u*d),p=m(f+f),p=m(p+f),g=m(c*g),w=m(y*w),p=m(p+g),g=m(f-g),g=m(c*g),w=m(w+g),f=m(p*w),h=m(h+f),f=m(S*w),u=m(v*u),u=m(u-f),f=m(v*p),d=m(S*d),d=m(d+f),new b(u,h,d)}mul(t,n=!0){if(!n&&0n===t)return v;if(d(t)||c("invalid scalar"),this.equals(g))return $(t).p;let e=v,r=g;for(let s=this;t>0n;s=s.double(),t>>=1n)1n&t?e=e.add(s):n&&(r=r.add(s));return e}mulAddQUns(t,n,e){return this.mul(n,!1).add(t.mul(e,!1)).ok()}toAffine(){const{px:t,py:n,pz:e}=this;if(this.equals(v))return{x:0n,y:0n};if(1n===e)return{x:t,y:n};const r=T(e);return 1n!==m(e*r)&&c("invalid inverse"),{x:m(t*r),y:m(n*r)}}assertValidity(){const{x:t,y:n}=this.aff();return h(t)&&h(n)||c("Point invalid: x or y"),m(n*n)===a(t)?this:c("Point invalid: not on curve")}multiply(t){return this.mul(t)}aff(){return this.toAffine()}ok(){return this.assertValidity()}toHex(t=!0){const{x:n,y:e}=this.aff();return(t?0n===(1n&e)?"02":"03":"04")+E(n)+(t?"":E(e))}toRawBytes(t=!0){return A(this.toHex(t))}}b.BASE=new b(r,s,1n),b.ZERO=new b(0n,1n,0n);const{BASE:g,ZERO:v}=b,w=(t,n)=>t.toString(16).padStart(n,"0"),S=t=>Array.from(t).map((t=>w(t,2))).join(""),A=t=>{const n=t.length;(!u(t)||n%2)&&c("hex invalid 1");const e=f(n/2);for(let n=0;n<e.length;n++){const r=2*n,s=t.slice(r,r+2),i=Number.parseInt(s,16);(Number.isNaN(i)||i<0)&&c("hex invalid 2"),e[n]=i}return e},B=t=>BigInt("0x"+(S(t)||"0")),P=(t,n,e)=>B(t.slice(n,e)),H=n=>l(n)&&n>=0n&&n<t?A(w(n,64)):c("bigint expected"),E=t=>S(H(t)),R=(...t)=>{const n=f(t.reduce(((t,n)=>t+y(n).length),0));let e=0;return t.forEach((t=>{n.set(t,e),e+=t.length})),n},T=(t,e=n)=>{(0n===t||e<=0n)&&c("no inverse n="+t+" mod="+e);let r=m(t,e),s=e,i=0n,o=1n;for(;0n!==r;){const t=s%r,n=i-o*(s/r);s=r,r=t,i=o,o=n}return 1n===s?m(i,e):c("no inverse")},V=t=>{let e=1n;for(let r=t,s=(n+1n)/4n;s>0n;s>>=1n)1n&s&&(e=e*r%n),r=r*r%n;return m(e*e)===t?e:c("sqrt invalid")},k=t=>(l(t)||(t=B(p(t,o))),d(t)?t:c("private key out of range")),z=t=>t>e>>1n,K=(t,n=!0)=>b.fromPrivateKey(t).toRawBytes(n);class C{constructor(t,n,e){this.r=t,this.s=n,this.recovery=e,this.assertValidity()}static fromCompact(t){return t=p(t,64),new C(P(t,0,o),P(t,o,64))}assertValidity(){return d(this.r)&&d(this.s)?this:c()}addRecoveryBit(t){return new C(this.r,this.s,t)}hasHighS(){return z(this.s)}normalizeS(){return this.hasHighS()?new C(this.r,m(this.s,e),this.recovery):this}recoverPublicKey(t){const{r:r,s:s,recovery:i}=this;[0,1,2,3].includes(i)||c("recovery id invalid");const a=U(p(t,o)),l=2===i||3===i?r+e:r;l>=n&&c("q.x invalid");const u=1&i?"03":"02",h=b.fromHex(u+E(l)),d=T(l,e),y=m(-a*d,e),f=m(s*d,e);return g.mulAddQUns(h,y,f)}toCompactRawBytes(){return A(this.toCompactHex())}toCompactHex(){return E(this.r)+E(this.s)}}const N=t=>{const n=8*t.length-256,e=B(t);return n>0?e>>BigInt(n):e},U=t=>m(N(t),e),j=t=>H(t),q=()=>"object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;let I;const O={lowS:!0},M={lowS:!0},Q=(t,n,r=O)=>{["der","recovered","canonical"].some((t=>t in r))&&c("sign() legacy options not supported");let{lowS:s}=r;null==s&&(s=!0);const i=U(p(t)),a=j(i),l=k(n),u=[j(l),a];let h=r.extraEntropy;if(h){!0===h&&(h=W.randomBytes(o));const t=p(h);t.length!==o&&c(),u.push(t)}const y=i;return{seed:R(...u),k2sig:t=>{const n=N(t);if(!d(n))return;const r=T(n,e),i=g.mul(n).aff(),o=m(i.x,e);if(0n===o)return;const a=m(r*m(y+m(l*o,e),e),e);if(0n===a)return;let c=a,u=(i.x===o?0:2)|Number(1n&i.y);return s&&z(a)&&(c=m(-a,e),u^=1),new C(o,c,u)}}};function Z(t){let n=f(o),e=f(o),r=0;const s=()=>{n.fill(1),e.fill(0),r=0},i="drbg: tried 1000 values";if(t){const t=(...t)=>W.hmacSha256Async(e,n,...t),o=async(r=f())=>{e=await t(f([0]),r),n=await t(),0!==r.length&&(e=await t(f([1]),r),n=await t())},a=async()=>(r++>=1e3&&c(i),n=await t(),n);return async(t,n)=>{let e;for(s(),await o(t);!(e=n(await a()));)await o();return s(),e}}{const t=(...t)=>{const r=I;return r||c("etc.hmacSha256Sync not set"),r(e,n,...t)},o=(r=f())=>{e=t(f([0]),r),n=t(),0!==r.length&&(e=t(f([1]),r),n=t())},a=()=>(r++>=1e3&&c(i),n=t(),n);return(t,n)=>{let e;for(s(),o(t);!(e=n(a()));)o();return s(),e}}}const G=async(t,n,e=O)=>{const{seed:r,k2sig:s}=Q(t,n,e);return Z(!0)(r,s)},F=(t,n,e=O)=>{const{seed:r,k2sig:s}=Q(t,n,e);return Z(!1)(r,s)},D=(t,n,r,s=M)=>{let i,o,a,{lowS:l}=s;null==l&&(l=!0),"strict"in s&&c("verify() legacy options not supported");const u=t&&"object"==typeof t&&"r"in t;u||64===p(t).length||c("signature must be 64 bytes");try{i=u?new C(t.r,t.s).assertValidity():C.fromCompact(t),o=U(p(n)),a=r instanceof b?r.ok():b.fromHex(r)}catch(t){return!1}if(!i)return!1;const{r:h,s:d}=i;if(l&&z(d))return!1;let y;try{const t=T(d,e),n=m(o*t,e),r=m(h*t,e);y=g.mulAddQUns(a,n,r).aff()}catch(t){return!1}if(!y)return!1;return m(y.x,e)===h},J=(t,n,e=!0)=>b.fromHex(n).mul(k(t)).toRawBytes(e),L=t=>{((t=p(t)).length<40||t.length>1024)&&c("expected proper params");const n=m(B(t),e-1n)+1n;return H(n)},W={hexToBytes:A,bytesToHex:S,concatBytes:R,bytesToNumberBE:B,numberToBytesBE:H,mod:m,invert:T,hmacSha256Async:async(t,...n)=>{const e=q(),r=e&&e.subtle;if(!r)return c("etc.hmacSha256Async not set");const s=await r.importKey("raw",t,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]);return f(await r.sign("HMAC",s,R(...n)))},hmacSha256Sync:I,hashToPrivateKey:L,randomBytes:(t=32)=>{const n=q();return n&&n.getRandomValues||c("crypto.getRandomValues must be defined"),n.getRandomValues(f(t))}},X={normPrivateKeyToScalar:k,isValidPrivateKey:t=>{try{return!!k(t)}catch(t){return!1}},randomPrivateKey:()=>L(W.randomBytes(48)),precompute:(t=8,n=g)=>(n.multiply(3n),n)};Object.defineProperties(W,{hmacSha256Sync:{configurable:!1,get:()=>I,set(t){I||(I=t)}}});let Y;const $=t=>{const n=Y||(Y=(()=>{const t=[];let n=g,e=n;for(let r=0;r<33;r++){e=n,t.push(e);for(let r=1;r<128;r++)e=e.add(n),t.push(e);n=e.double()}return t})()),e=(t,n)=>{let e=n.negate();return t?e:n};let r=v,s=g;const i=BigInt(255),o=BigInt(8);for(let a=0;a<33;a++){const c=128*a;let l=Number(t&i);t>>=o,l>128&&(l-=256,t+=1n);const u=c,h=c+Math.abs(l)-1,d=a%2!=0,y=l<0;0===l?s=s.add(e(d,n[u])):r=r.add(e(y,n[h]))}return{p:r,f:s}};export{i as CURVE,b as ProjectivePoint,C as Signature,W as etc,K as getPublicKey,J as getSharedSecret,F as sign,G as signAsync,X as utils,D as verify};export default null;
//# sourceMappingURL=/sm/8ab770afe49d2d31789e594ce70e0b43eeb5cc34aa65efb933ec1c87cb654a29.map